auto min :: func(float a, float b) bool {
    if (a < b) {
        return a
    }
    return b
}

auto max :: func(float a, float b) bool {
    if (a > b) {
        return a
    }
    return b
}

auto fib :: func(int n) int {
    print n
    if n = 0 {
        return 0
    } elif  n = 1 {
        return 1
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}

auto sqrt :: func(float n) float {
    auto lo  :: min(1.0, n)
    auto hi  :: max(1.0, n)
    auto mid :: 0.0
    
    for float j ::  0.0; (j < n); j :: 100.0 * lo * lo {
        lo :: lo * 10.0
    }

    for float k :: 0.0; (k > n); k :: 0.0001 * hi * hi {
        hi :: hi * 0.001
    }

    for int i :: 0 ; i < 100 ; i++ {
        mid :: (lo + hi)/2.0;
        if(mid * mid = n) {
            return mid
        }
        if(mid * mid > n) {
            hi :: mid
        } else {
            lo :: mid
        }
    }

    return mid
}

func(float, int) -> (float)
pow :: func(float a, int n) float {
    for int i :: 0; i < (n - 1); i++ {
        a :: a + a
    }
    return a
}

type Equation :: {
    auto a :: 0.0
    float b :: 0.0
    float c :: 0.0
}
auto solve_2nd :: func(Equation eq) [float] {
    auto delta ::  pow(eq.b, 2) - (4.0 * eq.a * eq.c)
    if delta < 0.0 {
        return [float]{};
    }
    if delta > 0.0 {
        return [float]{
            (-eq.b - sqrt(delta))/(2.0 * eq.a), 
            (-eq.b + sqrt(delta))/(2.0 * eq.a)
        }
    }
    return [float]{ (-eq.b)/(2.0 * eq.a)}
} 

auto eq :: new Equation{
    a :: 4.0, b :: 0.0, c :: -16.0,
}
print solve_2nd(eq)